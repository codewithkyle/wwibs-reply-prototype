new class{constructor(){this.queueTimeout=1e3,self.onmessage=this.handleMessage.bind(this),this.queuedMessages=[],this.queueTimer=null,this.inboxes=[],this.db=null,this.fallbackReplies=[],this.dbUid=this.uid();const e=indexedDB.open(`${this.dbUid}`,1);e.onsuccess=e=>{self.postMessage({recipient:"broadcaster",data:{type:"worker-ready"}})},e.onerror=()=>{console.warn("Failed to create database, using array fallback."),self.postMessage({recipient:"broadcaster",data:{type:"worker-ready"}})},e.onupgradeneeded=e=>{const s=e.target;this.db=s.result;const t=this.db.createObjectStore("history",{autoIncrement:!0});t.createIndex("messageUid","messageUid",{unique:!1}),t.createIndex("recipient","recipient",{unique:!1}),t.createIndex("senderID","senderID",{unique:!1}),t.createIndex("attempt","attempt",{unique:!1}),t.createIndex("data","data",{unique:!1});const a=this.db.createObjectStore("reply",{autoIncrement:!0});a.createIndex("replyID","replyID",{unique:!0}),a.createIndex("recipient","recipient",{unique:!1}),a.createIndex("senderID","senderID",{unique:!1})}}inbox(e){switch(e.type){case"hookup":this.addInbox(e);break;case"disconnect":this.removeInbox(e);break;case"update-addresses":this.updateAddressIndexes(e);break;case"init":this.handleUserDeviceInfo(e);break;case"unload":this.db&&indexedDB.deleteDatabase(this.dbUid);break;default:console.error(`Unknown broadcast-worker message type: ${e.type}`)}}handleMessage(e){const{recipient:s,data:t}=e.data;switch(s){case"broadcast-worker":this.inbox(t);break;case"broadcaster":self.postMessage(e.data);break;default:this.lookup(e.data)}}lookupReply(e){return new Promise(s=>{if(this.db)this.db.transaction("reply","readonly").objectStore("reply").index("replyID").get(e.replyID).onsuccess=e=>{s(e.target.result)};else for(let t=0;t<this.fallbackReplies.length;t++)if(this.fallbackReplies[t].replyID===e.replyID){s(this.fallbackReplies[t]);break}})}uid(){return new Array(4).fill(0).map(()=>Math.floor(Math.random()*Number.MAX_SAFE_INTEGER).toString(16)).join("-")}addInbox(e){const{name:s,inboxAddress:t,uid:a}=e,i={name:s.trim().toLowerCase(),address:t,uid:a};this.inboxes.push(i)}removeInbox(e){const{inboxAddress:s}=e;for(let e=0;e<this.inboxes.length;e++)if(this.inboxes[e].address===s){this.inboxes.splice(e,1);break}}updateAddressIndexes(e){const{addresses:s}=e;for(let e=0;e<s.length;e++)for(let t=0;t<this.inboxes.length;t++)if(s[e].oldAddressIndex===this.inboxes[e].address){this.inboxes[e].address=s[e].newAddressIndex;break}self.postMessage({recipient:"broadcaster",data:{type:"cleanup-complete"}})}async makeHistory(e){this.db&&new Promise((s,t)=>{var a;const i=this.db.transaction("history","readwrite"),r=i.objectStore("history"),n={senderID:null==e?void 0:e.senderID,messageUid:null==e?void 0:e.messageId,recipient:null===(a=null==e?void 0:e.recipient)||void 0===a?void 0:a.trim().toLowerCase(),data:null==e?void 0:e.data,attempt:null==e?void 0:e.attempts};r.add(n),i.oncomplete=s,i.onerror=t}).then(()=>{}).catch(e=>{console.error("Failed to write to the History table:",e)})}async logReply(e,s=null,t=null){if(this.db)new Promise((a,i)=>{const r=this.db.transaction("reply","readwrite"),n=r.objectStore("reply"),o={replyID:e,recipient:s,senderID:t};n.add(o),r.oncomplete=a,r.onerror=i}).then(()=>{}).catch(e=>{console.error("Failed to write to the Reply table:",e)});else{const a={replyID:e,recipient:s,senderID:t};this.fallbackReplies.push(a)}}async lookup(e){this.makeHistory(e);const s=[];let t=null;if(null==e?void 0:e.replyID){const a=await this.lookupReply(e);for(let e=0;e<this.inboxes.length;e++){const t=this.inboxes[e];t.uid===a.senderID&&s.push(t.address)}(null==e?void 0:e.replyAll)&&(t=a.recipient)}if((null==e?void 0:e.recipient)&&(t=e.recipient.trim().toLowerCase()),t)for(let e=0;e<this.inboxes.length;e++){const a=this.inboxes[e];a.name===t&&s.push(a.address)}if(s.length){const a={type:"lookup",data:e.data,inboxIndexes:s};if(null==e?void 0:e.senderID){const s=this.uid();a.data={...e.data,replyID:s},this.logReply(s,t,e.senderID)}self.postMessage(a)}else e.maxAttempts>1&&null!==e.messageId&&((null==e?void 0:e.attempts)<e.maxAttempts?e.attempts+=1:(null==e?void 0:e.attempts)===e.maxAttempts?this.dropMessageFromQueue(e.messageId):(e.attempts=1,this.queuedMessages.push(e),null===this.queueTimer&&(this.queueTimer=setTimeout(this.flushMessageQueue.bind(this),this.queueTimeout))))}flushMessageQueue(){for(let e=0;e<this.queuedMessages.length;e++)this.lookup(this.queuedMessages[e]);this.queuedMessages.length?this.queueTimer=setTimeout(this.flushMessageQueue.bind(this),this.queueTimeout):this.queueTimer=null}dropMessageFromQueue(e){for(let s=0;s<this.queuedMessages.length;s++)if(this.queuedMessages[s].messageId===e){this.queuedMessages.splice(s,1);break}}handleUserDeviceInfo(e){const{memory:s,isSafari:t}=e;s<=4?setInterval(()=>{self.postMessage({recipient:"broadcaster",data:{type:"cleanup"}})},6e4):setInterval(()=>{self.postMessage({recipient:"broadcaster",data:{type:"cleanup"}})},3e5),t&&setInterval(()=>{self.postMessage({recipient:"broadcaster",data:{type:"ping"}})},3e3)}generateUUID(){return new Array(4).fill(0).map(()=>Math.floor(Math.random()*Number.MAX_SAFE_INTEGER).toString(16)).join("-")}};